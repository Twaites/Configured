import pgClient from "./database/postgresql.js";
import redisClient from "./cache/redis.js";
import Ajv from "ajv";
export class Configured {
    constructor(machineName, configSchema, options, defaultConfig) {
        try {
            // Validate machineId and configSchema
            if (!machineName || typeof machineName !== "string") {
                throw new Error("Machine ID is required as a string");
            }
            if (!configSchema || typeof configSchema !== "object") {
                throw new Error("Config schema is required as an object");
            }
            // Initialize database and cache
            this.db = pgClient;
            this.cache = redisClient;
            this.machineName = machineName;
            this.options = options || {};
            // @ts-expect-error
            this.validator = new Ajv().compile(configSchema);
            this.config = defaultConfig || "";
            this.lastConfiguredId = null;
        }
        catch (error) {
            console.error(error);
            process.exit(1);
        }
    }
    async init() {
        console.log(`Configured initialized for: ${this.machineName}`);
        await this.validateDb();
        await this.worker(); // Run immediately on init
        setInterval(() => this.worker(), 2 * 60 * 1000); // Run every 2 minutes
    }
    get() {
        return this.config;
    }
    async set(config) {
        try {
            // Validate the config against schema
            const validConfig = this.validator(config);
            if (!validConfig) {
                console.error(`Invalid config: ${this.machineName}`);
                console.error(this.validator.errors);
                return false;
            }
            // Get schema and table name from options or defaults
            const schema = this.options.schema || 'public';
            const tableName = this.options.tableName || 'configured';
            // Insert new config into database
            const result = await this.db.query(`INSERT INTO ${schema}.${tableName} 
         (machine_name, config) 
         VALUES ($1, $2) 
         RETURNING uuid`, [this.machineName, config]);
            const uuid = result.rows[0].uuid;
            // Update Redis cache
            await this.cache.set("last_configured", uuid, "EX", this.options.redisExpirationSeconds || 300);
            await this.cache.set("configured", config);
            // Update local state
            this.lastConfiguredId = uuid;
            this.config = config;
            return true;
        }
        catch (error) {
            console.error('Failed to set configuration:', error);
            return false;
        }
    }
    async validateDb() {
        try {
            // Check if table exists
            const tableCheck = await this.db.query(`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_name = 'configured'
        );
      `);
            if (!tableCheck.rows[0].exists) {
                // Create table if it doesn't exist
                await this.db.query(`
          create table public.configured (
            id bigint generated by default as identity not null,
            uuid uuid not null default gen_random_uuid(),
            created_at timestamp with time zone not null default now(),
            machine_name character varying not null,
            config json not null,
            deleted boolean not null default false,
            constraint Configured_pkey primary key (id),
            constraint Configured_id_key unique (id),
            constraint Configured_uuid_key unique (uuid)
          );
        `);
                console.log('Created public.configured table');
            }
        }
        catch (error) {
            console.error('Database validation failed:', error);
            process.exit(1);
        }
    }
    async worker() {
        try {
            const { schema, tableName, redisExpirationSeconds } = this.options;
            let lcId = await this.cache.get("last_configured");
            if (lcId === null) {
                await this.db
                    .query(`SELECT uuid, config FROM ${schema}.${tableName} WHERE deleted = false ORDER BY created_at DESC LIMIT 1`)
                    .then(async (res) => {
                    const configs = res.rows.map((row) => {
                        return {
                            uuid: row.uuid,
                            config: row.config,
                        };
                    });
                    if (configs.length === 0)
                        throw new Error("No configs found in database.");
                    if (!this.validator(configs[0].config))
                        throw new Error("Invalid config");
                    await this.cache.set("last_configured", configs[0].uuid, "EX", redisExpirationSeconds || 300);
                    await this.cache.set("configured", JSON.stringify(configs[0].config));
                    lcId = configs[0].uuid;
                });
            }
            if (lcId !== this.lastConfiguredId) {
                this.lastConfiguredId = await this.cache.get("last_configured");
                this.config = (await this.cache.get("configured")) || "";
            }
        }
        catch (error) {
            console.error(error);
            process.exit(1);
        }
    }
}
