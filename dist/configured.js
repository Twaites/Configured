import pgClient from "./database/postgresql.js";
import redisClient from "./cache/redis.js";
import Ajv from "ajv";
export class Configured {
    constructor(machineName, configSchema, defaultConfig) {
        try {
            // Validate machineId and configSchema
            if (!machineName || typeof machineName !== "string") {
                throw new Error("Machine ID is required as a string");
            }
            if (!configSchema || typeof configSchema !== "object") {
                throw new Error("Config schema is required as an object");
            }
            // Initialize database and cache
            this.db = pgClient;
            this.cache = redisClient;
            this.machineName = machineName;
            // @ts-expect-error
            this.validator = new Ajv().compile(configSchema);
            this.config = defaultConfig || "";
            this.lastConfiguredId = null;
        }
        catch (error) {
            console.error(error);
            process.exit(1);
        }
    }
    async init() {
        console.log(`Configured initialized for: ${this.machineName}`);
        await this.validateDb();
        await this.worker(); // Run immediately on init
        setInterval(() => this.worker(), 2 * 60 * 1000); // Run every 2 minutes
    }
    get() {
        return this.config;
    }
    set(config) {
        const validConfig = this.validator(config);
        if (!validConfig) {
            console.error(`Invalid config: ${this.machineName}`);
            console.error(this.validator.errors);
            return;
        }
        this.config = config;
    }
    async validateDb() {
        try {
            // Check if table exists
            const tableCheck = await this.db.query(`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_name = 'configured'
        );
      `);
            if (!tableCheck.rows[0].exists) {
                // Create table if it doesn't exist
                await this.db.query(`
          create table public.configured (
            id bigint generated by default as identity not null,
            uuid uuid not null default gen_random_uuid(),
            created_at timestamp with time zone not null default now(),
            machine_name character varying not null,
            config json not null,
            deleted boolean not null default false,
            constraint Configured_pkey primary key (id),
            constraint Configured_id_key unique (id),
            constraint Configured_uuid_key unique (uuid)
          );
        `);
                console.log('Created public.configured table');
            }
        }
        catch (error) {
            console.error('Database validation failed:', error);
            process.exit(1);
        }
    }
    async worker() {
        try {
            let lcId = await this.cache.get("last_configured");
            if (lcId === null) {
                // console.log("Redis is empty, fetching new config...");
                await this.db
                    .query("SELECT uuid, config FROM public.configured WHERE deleted = false ORDER BY created_at DESC LIMIT 1")
                    .then(async (res) => {
                    const configs = res.rows.map((row) => {
                        return {
                            uuid: row.uuid,
                            config: row.config,
                        };
                    });
                    if (configs.length === 0)
                        throw new Error("No configs found in database.");
                    if (!this.validator(configs[0].config))
                        throw new Error("Invalid config");
                    await this.cache.set("last_configured", configs[0].uuid, "EX", 300);
                    await this.cache.set("configured", JSON.stringify(configs[0].config));
                    lcId = configs[0].uuid;
                });
            }
            if (lcId !== this.lastConfiguredId) {
                // console.log("Local config is outdated, fetching new config...");
                this.lastConfiguredId = await this.cache.get("last_configured");
                this.config = (await this.cache.get("configured")) || "";
            }
        }
        catch (error) {
            console.error(error);
            process.exit(1);
        }
    }
}
